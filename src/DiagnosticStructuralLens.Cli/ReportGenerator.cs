using System.Text;
using DiagnosticStructuralLens.Cli.Analyzers;
using DiagnosticStructuralLens.Core;
using DiagnosticStructuralLens.Linker;
using DiagnosticStructuralLens.Risk;

namespace DiagnosticStructuralLens.Cli;

/// <summary>
/// Generates a comprehensive markdown architecture report from scan results.
/// Uses user-friendly terminology: Components, Database Objects, Relationships.
/// </summary>
public static class ReportGenerator
{
    public static string GenerateMarkdownReport(
        Snapshot snapshot,
        RiskReport riskReport,
        List<ScanDiagnostic> diagnostics,
        List<string> governanceViolations,
        AnalysisReport? analysisReport = null,
        PolicyResult? policyResult = null,
        int topN = 10)
    {
        var sb = new StringBuilder();
        var linker = new SemanticLinker();

        // Header
        sb.AppendLine($"# üó∫Ô∏è Architecture Report ‚Äî {snapshot.Repository}");
        sb.AppendLine();
        var branch = !string.IsNullOrEmpty(snapshot.Branch) ? $"`{snapshot.Branch}`" : "_unknown_";
        var commit = !string.IsNullOrEmpty(snapshot.CommitSha) ? $"`{snapshot.CommitSha}`" : "_unknown_";
        sb.AppendLine($"**Branch**: {branch}  |  **Commit**: {commit}  |  **Generated**: {DateTime.Now:yyyy-MM-dd HH:mm}");
        sb.AppendLine();
        sb.AppendLine("---");
        sb.AppendLine();

        // 1. Vital Signs
        AppendVitalSigns(sb, snapshot);

        // 2. Component Taxonomy
        AppendTaxonomy(sb, snapshot);

        // 3. Architecture Breakdown
        AppendNamespaceBreakdown(sb, snapshot);

        // 4. Connectivity ‚Äî Central Nodes
        AppendConnectivity(sb, snapshot, linker, topN);

        // 5. Risk Assessment
        AppendRiskAssessment(sb, snapshot, riskReport, topN);

        // 6. Governance Violations
        AppendGovernance(sb, governanceViolations);

        // 7-9. Analyzer Findings (only if analyzers were run)
        int sectionNum = 7;
        if (analysisReport != null)
        {
            if (analysisReport.HasCategory(FindingCategory.Architecture))
            {
                AppendAnalyzerFindings(sb, analysisReport, FindingCategory.Architecture,
                    sectionNum++, "Architecture Findings",
                    "Structural patterns and code smells detected by automated analysis.");
            }

            if (analysisReport.HasCategory(FindingCategory.Migration))
            {
                AppendAnalyzerFindings(sb, analysisReport, FindingCategory.Migration,
                    sectionNum++, "Migration Readiness (.NET Framework ‚Üí .NET Core)",
                    "Patterns requiring attention for .NET Core migration.");
            }

            if (analysisReport.HasCategory(FindingCategory.Modernization))
            {
                AppendAnalyzerFindings(sb, analysisReport, FindingCategory.Modernization,
                    sectionNum++, "Modernization Opportunities",
                    "Patterns that work but could be improved for performance, maintainability, or cloud-readiness.");
            }
        }

        // Policy Gate Results (CI/CD mode)
        if (policyResult != null)
        {
            AppendPolicyResults(sb, policyResult, sectionNum++);
        }

        // Diagnostics & Recommendations
        AppendDiagnostics(sb, snapshot, diagnostics, sectionNum);

        // Footer
        sb.AppendLine("---");
        sb.AppendLine();
        sb.AppendLine($"*Generated by [Diagnostic Structural Lens](https://github.com/cmvayette/DiagnosticStructuralLens) v0.3.0*");

        return sb.ToString();
    }

    private static void AppendVitalSigns(StringBuilder sb, Snapshot snapshot)
    {
        var totalComponents = snapshot.Metadata.TotalCodeAtoms;
        var totalDbObjects = snapshot.Metadata.TotalSqlAtoms;
        var totalRelationships = snapshot.Metadata.TotalLinks;
        var totalElements = totalComponents + totalDbObjects;
        var couplingDensity = totalElements > 0
            ? (double)totalRelationships / totalElements
            : 0.0;

        sb.AppendLine("## 1. Vital Signs");
        sb.AppendLine();
        sb.AppendLine("| Metric | Value |");
        sb.AppendLine("|--------|-------|");
        sb.AppendLine($"| Components | {totalComponents:N0} |");
        sb.AppendLine($"| Database Objects | {totalDbObjects:N0} |");
        sb.AppendLine($"| Relationships | {totalRelationships:N0} |");
        sb.AppendLine($"| Coupling Density | {couplingDensity:F2} relationships/element |");
        sb.AppendLine($"| Scan Duration | {snapshot.Metadata.ScanDuration.TotalSeconds:F2}s |");
        sb.AppendLine();
    }

    private static void AppendTaxonomy(StringBuilder sb, Snapshot snapshot)
    {
        sb.AppendLine("## 2. Component Taxonomy");
        sb.AppendLine();
        sb.AppendLine("| Type | Count |");
        sb.AppendLine("|------|-------|");

        // Code component types
        var codeGroups = snapshot.CodeAtoms
            .GroupBy(a => a.Type)
            .OrderByDescending(g => g.Count())
            .ToList();

        foreach (var group in codeGroups)
        {
            var label = FormatAtomType(group.Key);
            sb.AppendLine($"| {label} | {group.Count():N0} |");
        }

        // Database object types
        var sqlGroups = snapshot.SqlAtoms
            .GroupBy(a => a.Type)
            .OrderByDescending(g => g.Count())
            .ToList();

        foreach (var group in sqlGroups)
        {
            var label = FormatSqlType(group.Key);
            sb.AppendLine($"| {label} | {group.Count():N0} |");
        }

        sb.AppendLine();
    }

    private static void AppendNamespaceBreakdown(StringBuilder sb, Snapshot snapshot)
    {
        var totalAtoms = snapshot.CodeAtoms.Count;
        if (totalAtoms == 0) return;

        var topNamespaces = snapshot.CodeAtoms
            .GroupBy(a => a.Namespace)
            .OrderByDescending(g => g.Count())
            .Take(15)
            .ToList();

        sb.AppendLine("## 3. Architecture Breakdown");
        sb.AppendLine();
        sb.AppendLine("| Namespace | Components | % of Total |");
        sb.AppendLine("|-----------|-----------|-----------|");

        foreach (var ns in topNamespaces)
        {
            var pct = (double)ns.Count() / totalAtoms * 100;
            var name = string.IsNullOrWhiteSpace(ns.Key) ? "_root_" : $"`{ns.Key}`";
            sb.AppendLine($"| {name} | {ns.Count():N0} | {pct:F1}% |");
        }

        sb.AppendLine();
    }

    private static void AppendConnectivity(StringBuilder sb, Snapshot snapshot, SemanticLinker linker, int topN)
    {
        sb.AppendLine("## 4. Connectivity ‚Äî Central Nodes");
        sb.AppendLine();
        sb.AppendLine("> These elements have the highest fan-in + fan-out. Changes here ripple widely.");
        sb.AppendLine();

        // Calculate connection counts
        var linkCounts = new Dictionary<string, int>();
        foreach (var link in snapshot.Links)
        {
            linkCounts[link.SourceId] = linkCounts.GetValueOrDefault(link.SourceId) + 1;
            linkCounts[link.TargetId] = linkCounts.GetValueOrDefault(link.TargetId) + 1;
        }

        var topNodes = linkCounts
            .OrderByDescending(kv => kv.Value)
            .Take(topN)
            .ToList();

        if (topNodes.Count == 0)
        {
            sb.AppendLine("_No relationships detected._");
            sb.AppendLine();
            return;
        }

        sb.AppendLine("| Element | Connections | Impact Radius |");
        sb.AppendLine("|---------|-----------|--------------|");

        foreach (var node in topNodes)
        {
            var name = ResolveAtomName(snapshot, node.Key);
            var blastRadius = linker.GetBlastRadius(node.Key, snapshot.Links, 3);
            sb.AppendLine($"| `{name}` | {node.Value:N0} | {blastRadius.TotalAffected:N0} elements |");
        }

        sb.AppendLine();
    }

    private static void AppendRiskAssessment(StringBuilder sb, Snapshot snapshot, RiskReport riskReport, int topN)
    {
        sb.AppendLine("## 5. Risk Assessment");
        sb.AppendLine();

        // Summary counts
        sb.AppendLine("| Level | Count |");
        sb.AppendLine("|-------|-------|");
        sb.AppendLine($"| üî¥ Critical | {riskReport.Stats.CriticalCount} |");
        sb.AppendLine($"| üü† High | {riskReport.Stats.HighCount} |");
        sb.AppendLine($"| üü° Medium | {riskReport.Stats.MediumCount} |");
        sb.AppendLine($"| üü¢ Low | {riskReport.Stats.LowCount} |");
        sb.AppendLine();

        // Top risky elements
        var topRisks = riskReport.Scores.Take(topN).ToList();
        if (topRisks.Count > 0)
        {
            sb.AppendLine("### Highest Risk Components");
            sb.AppendLine();
            sb.AppendLine("| Component | Score | Level |");
            sb.AppendLine("|-----------|-------|-------|");

            foreach (var score in topRisks)
            {
                var name = ResolveAtomName(snapshot, score.AtomId);
                var icon = score.Level switch
                {
                    RiskLevel.Critical => "üî¥",
                    RiskLevel.High => "üü†",
                    RiskLevel.Medium => "üü°",
                    _ => "üü¢"
                };
                sb.AppendLine($"| `{name}` | {score.CompositeScore:F1} | {icon} {score.Level} |");
            }

            sb.AppendLine();
        }
    }

    private static void AppendGovernance(StringBuilder sb, List<string> governanceViolations)
    {
        sb.AppendLine("## 6. Governance");
        sb.AppendLine();

        if (governanceViolations.Count == 0)
        {
            sb.AppendLine("‚úÖ No governance violations detected.");
            sb.AppendLine();
            return;
        }

        sb.AppendLine($"‚ö†Ô∏è **{governanceViolations.Count} violation(s) found:**");
        sb.AppendLine();

        foreach (var violation in governanceViolations)
        {
            sb.AppendLine($"- ‚ùå {violation}");
        }

        sb.AppendLine();
    }

    private static void AppendAnalyzerFindings(StringBuilder sb, AnalysisReport report,
        FindingCategory category, int sectionNum, string title, string subtitle)
    {
        var findings = report.ByCategory(category).ToList();
        if (findings.Count == 0) return;

        sb.AppendLine($"## {sectionNum}. {title}");
        sb.AppendLine();
        sb.AppendLine($"> {subtitle}");
        sb.AppendLine();

        // Summary by severity
        var critical = findings.Count(f => f.Severity == FindingSeverity.Critical);
        var high = findings.Count(f => f.Severity == FindingSeverity.High);
        var medium = findings.Count(f => f.Severity == FindingSeverity.Medium);
        var low = findings.Count(f => f.Severity == FindingSeverity.Low);

        sb.AppendLine("| Level | Count |");
        sb.AppendLine("|-------|-------|");
        if (critical > 0) sb.AppendLine($"| üî¥ Critical | {critical} |");
        if (high > 0) sb.AppendLine($"| üü† High | {high} |");
        if (medium > 0) sb.AppendLine($"| üü° Medium | {medium} |");
        if (low > 0) sb.AppendLine($"| üü¢ Low | {low} |");
        sb.AppendLine();

        // Detail table
        sb.AppendLine("| Rule | Finding | Severity | Occurrences |");
        sb.AppendLine("|------|---------|----------|-------------|");

        foreach (var finding in findings)
        {
            var icon = finding.Severity switch
            {
                FindingSeverity.Critical => "üî¥",
                FindingSeverity.High => "üü†",
                FindingSeverity.Medium => "üü°",
                _ => "üü¢"
            };
            var file = finding.FilePath != null
                ? $" (`{TruncatePath(finding.FilePath)}`)"
                : "";
            sb.AppendLine($"| `{finding.RuleId}` | {EscapeMarkdown(finding.Title)}{file} | {icon} {finding.Severity} | {finding.Occurrences} |");
        }

        sb.AppendLine();

        // Remediation guidance for top findings
        var topFindings = findings.Where(f => f.Severity <= FindingSeverity.High).Take(5).ToList();
        if (topFindings.Count > 0)
        {
            sb.AppendLine("<details>");
            sb.AppendLine($"<summary>üìã Remediation Guidance ({topFindings.Count} items)</summary>");
            sb.AppendLine();
            foreach (var f in topFindings)
            {
                sb.AppendLine($"**{f.RuleId}: {f.Title}**");
                sb.AppendLine($"> {f.Description}");
                sb.AppendLine();
            }
            sb.AppendLine("</details>");
            sb.AppendLine();
        }
    }

    private static void AppendPolicyResults(StringBuilder sb, PolicyResult result, int sectionNum)
    {
        var icon = result.Passed ? "‚úÖ" : "‚ùå";
        sb.AppendLine($"## {sectionNum}. Policy Gate Results ‚Äî {icon} {(result.Passed ? "PASSED" : "FAILED")}");
        sb.AppendLine();

        sb.AppendLine("| Gate | Status | Actual | Threshold |");
        sb.AppendLine("|------|--------|--------|----------|");

        foreach (var gate in result.Gates)
        {
            var status = gate.Passed ? "‚úÖ Pass" : "‚ùå **FAIL**";
            var threshold = gate.Threshold.HasValue ? gate.Threshold.Value.ToString() : gate.Details ?? "‚Äî";
            sb.AppendLine($"| {gate.Name} | {status} | {gate.Actual} | {threshold} |");
        }

        sb.AppendLine();
    }

    private static void AppendDiagnostics(StringBuilder sb, Snapshot snapshot, List<ScanDiagnostic> diagnostics, int sectionNum)
    {
        sb.AppendLine($"## {sectionNum}. Diagnostics & Recommendations");
        sb.AppendLine();

        // Automated recommendations based on data
        if (snapshot.Metadata.InterfaceCount == 0)
        {
            sb.AppendLine("- ‚ö†Ô∏è **Low Abstraction**: No interfaces found. Consider introducing interfaces for better testability and decoupling.");
        }
        else
        {
            sb.AppendLine($"- ‚úÖ **Good Abstraction**: {snapshot.Metadata.InterfaceCount} interfaces detected ‚Äî suggests a well-decoupled architecture.");
        }

        if (snapshot.Metadata.DtoCount > snapshot.Metadata.TotalCodeAtoms * 0.5)
        {
            sb.AppendLine("- ‚ÑπÔ∏è **Data-Heavy**: High ratio of DTOs suggests a data transformation pipeline or CRUD application.");
        }

        var totalElements = snapshot.Metadata.TotalCodeAtoms + snapshot.Metadata.TotalSqlAtoms;
        var density = totalElements > 0
            ? (double)snapshot.Metadata.TotalLinks / totalElements
            : 0;

        if (density > 5.0)
        {
            sb.AppendLine($"- ‚ö†Ô∏è **High Coupling**: Coupling density of {density:F2} ‚Äî consider breaking apart tightly coupled modules.");
        }
        else if (density < 1.0 && totalElements > 10)
        {
            sb.AppendLine($"- ‚ÑπÔ∏è **Low Connectivity**: Coupling density of {density:F2} ‚Äî components may be under-documented or isolated.");
        }

        sb.AppendLine();

        // Scan warnings
        if (diagnostics.Count > 0)
        {
            sb.AppendLine("### Scan Warnings");
            sb.AppendLine();
            sb.AppendLine("| Severity | Message | File |");
            sb.AppendLine("|----------|---------|------|");

            foreach (var diag in diagnostics.Take(20))
            {
                var icon = diag.Severity switch
                {
                    DiagnosticSeverity.Error => "‚ùå Error",
                    DiagnosticSeverity.Warning => "‚ö†Ô∏è Warning",
                    _ => "‚ÑπÔ∏è Info"
                };
                var file = diag.FilePath ?? "‚Äî";
                if (file.Length > 60)
                    file = "‚Ä¶" + file[^55..];
                sb.AppendLine($"| {icon} | {EscapeMarkdown(diag.Message)} | `{file}` |");
            }

            if (diagnostics.Count > 20)
                sb.AppendLine($"| | _...and {diagnostics.Count - 20} more_ | |");

            sb.AppendLine();
        }
    }

    private static string TruncatePath(string path)
    {
        if (path.Length <= 50) return path;
        return "‚Ä¶" + path[^45..];
    }

    // --- Helpers ---

    private static string ResolveAtomName(Snapshot snapshot, string atomId)
    {
        return snapshot.CodeAtoms.FirstOrDefault(a => a.Id == atomId)?.Name
            ?? snapshot.SqlAtoms.FirstOrDefault(a => a.Id == atomId)?.Name
            ?? atomId;
    }

    private static string FormatAtomType(AtomType type) => type switch
    {
        AtomType.Class => "Classes",
        AtomType.Interface => "Interfaces",
        AtomType.Record => "Records",
        AtomType.Struct => "Structs",
        AtomType.Enum => "Enums",
        AtomType.Method => "Methods",
        AtomType.Property => "Properties",
        AtomType.Field => "Fields",
        AtomType.Dto => "DTOs",
        AtomType.TypeAlias => "Type Aliases",
        AtomType.Module => "Modules",
        AtomType.Component => "Components (UI)",
        _ => type.ToString()
    };

    private static string FormatSqlType(SqlAtomType type) => type switch
    {
        SqlAtomType.Table => "Tables",
        SqlAtomType.Column => "Columns",
        SqlAtomType.StoredProcedure => "Stored Procedures",
        SqlAtomType.View => "Views",
        SqlAtomType.Function => "Functions (DB)",
        SqlAtomType.Index => "Indexes",
        _ => type.ToString()
    };

    private static string EscapeMarkdown(string text)
    {
        return text
            .Replace("|", "\\|")
            .Replace("\n", " ")
            .Replace("\r", "");
    }
}
